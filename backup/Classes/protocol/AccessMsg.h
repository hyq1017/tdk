// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AccessMsg.proto

#ifndef PROTOBUF_AccessMsg_2eproto__INCLUDED
#define PROTOBUF_AccessMsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_AccessMsg_2eproto();
void protobuf_AssignDesc_AccessMsg_2eproto();
void protobuf_ShutdownFile_AccessMsg_2eproto();

class LoginReq;
class LoginRsp;
class UserInfo;
class HallBoard;

// ===================================================================

class LoginReq : public ::google::protobuf::Message {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReq& default_instance();

  void Swap(LoginReq* other);

  // implements Message ----------------------------------------------

  LoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional int32 opt1 = 3;
  inline bool has_opt1() const;
  inline void clear_opt1();
  static const int kOpt1FieldNumber = 3;
  inline ::google::protobuf::int32 opt1() const;
  inline void set_opt1(::google::protobuf::int32 value);

  // optional string opt2 = 4;
  inline bool has_opt2() const;
  inline void clear_opt2();
  static const int kOpt2FieldNumber = 4;
  inline const ::std::string& opt2() const;
  inline void set_opt2(const ::std::string& value);
  inline void set_opt2(const char* value);
  inline void set_opt2(const char* value, size_t size);
  inline ::std::string* mutable_opt2();
  inline ::std::string* release_opt2();
  inline void set_allocated_opt2(::std::string* opt2);

  // @@protoc_insertion_point(class_scope:LoginReq)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_opt1();
  inline void clear_has_opt1();
  inline void set_has_opt2();
  inline void clear_has_opt2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;
  ::std::string* opt2_;
  ::google::protobuf::int32 opt1_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_AccessMsg_2eproto();
  friend void protobuf_AssignDesc_AccessMsg_2eproto();
  friend void protobuf_ShutdownFile_AccessMsg_2eproto();

  void InitAsDefaultInstance();
  static LoginReq* default_instance_;
};
// -------------------------------------------------------------------

class LoginRsp : public ::google::protobuf::Message {
 public:
  LoginRsp();
  virtual ~LoginRsp();

  LoginRsp(const LoginRsp& from);

  inline LoginRsp& operator=(const LoginRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRsp& default_instance();

  void Swap(LoginRsp* other);

  // implements Message ----------------------------------------------

  LoginRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRsp& from);
  void MergeFrom(const LoginRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required string fail_result = 2;
  inline bool has_fail_result() const;
  inline void clear_fail_result();
  static const int kFailResultFieldNumber = 2;
  inline const ::std::string& fail_result() const;
  inline void set_fail_result(const ::std::string& value);
  inline void set_fail_result(const char* value);
  inline void set_fail_result(const char* value, size_t size);
  inline ::std::string* mutable_fail_result();
  inline ::std::string* release_fail_result();
  inline void set_allocated_fail_result(::std::string* fail_result);

  // optional string opt2 = 3;
  inline bool has_opt2() const;
  inline void clear_opt2();
  static const int kOpt2FieldNumber = 3;
  inline const ::std::string& opt2() const;
  inline void set_opt2(const ::std::string& value);
  inline void set_opt2(const char* value);
  inline void set_opt2(const char* value, size_t size);
  inline ::std::string* mutable_opt2();
  inline ::std::string* release_opt2();
  inline void set_allocated_opt2(::std::string* opt2);

  // @@protoc_insertion_point(class_scope:LoginRsp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_fail_result();
  inline void clear_has_fail_result();
  inline void set_has_opt2();
  inline void clear_has_opt2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fail_result_;
  ::std::string* opt2_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_AccessMsg_2eproto();
  friend void protobuf_AssignDesc_AccessMsg_2eproto();
  friend void protobuf_ShutdownFile_AccessMsg_2eproto();

  void InitAsDefaultInstance();
  static LoginRsp* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gold_count = 1;
  inline bool has_gold_count() const;
  inline void clear_gold_count();
  static const int kGoldCountFieldNumber = 1;
  inline ::google::protobuf::int32 gold_count() const;
  inline void set_gold_count(::google::protobuf::int32 value);

  // required int32 user_type = 2;
  inline bool has_user_type() const;
  inline void clear_user_type();
  static const int kUserTypeFieldNumber = 2;
  inline ::google::protobuf::int32 user_type() const;
  inline void set_user_type(::google::protobuf::int32 value);

  // required int32 user_grade = 3;
  inline bool has_user_grade() const;
  inline void clear_user_grade();
  static const int kUserGradeFieldNumber = 3;
  inline ::google::protobuf::int32 user_grade() const;
  inline void set_user_grade(::google::protobuf::int32 value);

  // optional string opt1 = 4;
  inline bool has_opt1() const;
  inline void clear_opt1();
  static const int kOpt1FieldNumber = 4;
  inline const ::std::string& opt1() const;
  inline void set_opt1(const ::std::string& value);
  inline void set_opt1(const char* value);
  inline void set_opt1(const char* value, size_t size);
  inline ::std::string* mutable_opt1();
  inline ::std::string* release_opt1();
  inline void set_allocated_opt1(::std::string* opt1);

  // optional string opt2 = 5;
  inline bool has_opt2() const;
  inline void clear_opt2();
  static const int kOpt2FieldNumber = 5;
  inline const ::std::string& opt2() const;
  inline void set_opt2(const ::std::string& value);
  inline void set_opt2(const char* value);
  inline void set_opt2(const char* value, size_t size);
  inline ::std::string* mutable_opt2();
  inline ::std::string* release_opt2();
  inline void set_allocated_opt2(::std::string* opt2);

  // @@protoc_insertion_point(class_scope:UserInfo)
 private:
  inline void set_has_gold_count();
  inline void clear_has_gold_count();
  inline void set_has_user_type();
  inline void clear_has_user_type();
  inline void set_has_user_grade();
  inline void clear_has_user_grade();
  inline void set_has_opt1();
  inline void clear_has_opt1();
  inline void set_has_opt2();
  inline void clear_has_opt2();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gold_count_;
  ::google::protobuf::int32 user_type_;
  ::std::string* opt1_;
  ::std::string* opt2_;
  ::google::protobuf::int32 user_grade_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_AccessMsg_2eproto();
  friend void protobuf_AssignDesc_AccessMsg_2eproto();
  friend void protobuf_ShutdownFile_AccessMsg_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class HallBoard : public ::google::protobuf::Message {
 public:
  HallBoard();
  virtual ~HallBoard();

  HallBoard(const HallBoard& from);

  inline HallBoard& operator=(const HallBoard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HallBoard& default_instance();

  void Swap(HallBoard* other);

  // implements Message ----------------------------------------------

  HallBoard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HallBoard& from);
  void MergeFrom(const HallBoard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string board1 = 1;
  inline bool has_board1() const;
  inline void clear_board1();
  static const int kBoard1FieldNumber = 1;
  inline const ::std::string& board1() const;
  inline void set_board1(const ::std::string& value);
  inline void set_board1(const char* value);
  inline void set_board1(const char* value, size_t size);
  inline ::std::string* mutable_board1();
  inline ::std::string* release_board1();
  inline void set_allocated_board1(::std::string* board1);

  // required string board2 = 2;
  inline bool has_board2() const;
  inline void clear_board2();
  static const int kBoard2FieldNumber = 2;
  inline const ::std::string& board2() const;
  inline void set_board2(const ::std::string& value);
  inline void set_board2(const char* value);
  inline void set_board2(const char* value, size_t size);
  inline ::std::string* mutable_board2();
  inline ::std::string* release_board2();
  inline void set_allocated_board2(::std::string* board2);

  // required string board3 = 3;
  inline bool has_board3() const;
  inline void clear_board3();
  static const int kBoard3FieldNumber = 3;
  inline const ::std::string& board3() const;
  inline void set_board3(const ::std::string& value);
  inline void set_board3(const char* value);
  inline void set_board3(const char* value, size_t size);
  inline ::std::string* mutable_board3();
  inline ::std::string* release_board3();
  inline void set_allocated_board3(::std::string* board3);

  // required string board4 = 4;
  inline bool has_board4() const;
  inline void clear_board4();
  static const int kBoard4FieldNumber = 4;
  inline const ::std::string& board4() const;
  inline void set_board4(const ::std::string& value);
  inline void set_board4(const char* value);
  inline void set_board4(const char* value, size_t size);
  inline ::std::string* mutable_board4();
  inline ::std::string* release_board4();
  inline void set_allocated_board4(::std::string* board4);

  // optional string board5 = 5;
  inline bool has_board5() const;
  inline void clear_board5();
  static const int kBoard5FieldNumber = 5;
  inline const ::std::string& board5() const;
  inline void set_board5(const ::std::string& value);
  inline void set_board5(const char* value);
  inline void set_board5(const char* value, size_t size);
  inline ::std::string* mutable_board5();
  inline ::std::string* release_board5();
  inline void set_allocated_board5(::std::string* board5);

  // optional string board6 = 6;
  inline bool has_board6() const;
  inline void clear_board6();
  static const int kBoard6FieldNumber = 6;
  inline const ::std::string& board6() const;
  inline void set_board6(const ::std::string& value);
  inline void set_board6(const char* value);
  inline void set_board6(const char* value, size_t size);
  inline ::std::string* mutable_board6();
  inline ::std::string* release_board6();
  inline void set_allocated_board6(::std::string* board6);

  // @@protoc_insertion_point(class_scope:HallBoard)
 private:
  inline void set_has_board1();
  inline void clear_has_board1();
  inline void set_has_board2();
  inline void clear_has_board2();
  inline void set_has_board3();
  inline void clear_has_board3();
  inline void set_has_board4();
  inline void clear_has_board4();
  inline void set_has_board5();
  inline void clear_has_board5();
  inline void set_has_board6();
  inline void clear_has_board6();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* board1_;
  ::std::string* board2_;
  ::std::string* board3_;
  ::std::string* board4_;
  ::std::string* board5_;
  ::std::string* board6_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_AccessMsg_2eproto();
  friend void protobuf_AssignDesc_AccessMsg_2eproto();
  friend void protobuf_ShutdownFile_AccessMsg_2eproto();

  void InitAsDefaultInstance();
  static HallBoard* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginReq

// required string username = 1;
inline bool LoginReq::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReq::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReq::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReq::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& LoginReq::username() const {
  return *username_;
}
inline void LoginReq::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginReq::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginReq::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* LoginReq::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string password = 2;
inline bool LoginReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginReq::password() const {
  return *password_;
}
inline void LoginReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 opt1 = 3;
inline bool LoginReq::has_opt1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginReq::set_has_opt1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginReq::clear_has_opt1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginReq::clear_opt1() {
  opt1_ = 0;
  clear_has_opt1();
}
inline ::google::protobuf::int32 LoginReq::opt1() const {
  return opt1_;
}
inline void LoginReq::set_opt1(::google::protobuf::int32 value) {
  set_has_opt1();
  opt1_ = value;
}

// optional string opt2 = 4;
inline bool LoginReq::has_opt2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginReq::set_has_opt2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginReq::clear_has_opt2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginReq::clear_opt2() {
  if (opt2_ != &::google::protobuf::internal::kEmptyString) {
    opt2_->clear();
  }
  clear_has_opt2();
}
inline const ::std::string& LoginReq::opt2() const {
  return *opt2_;
}
inline void LoginReq::set_opt2(const ::std::string& value) {
  set_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    opt2_ = new ::std::string;
  }
  opt2_->assign(value);
}
inline void LoginReq::set_opt2(const char* value) {
  set_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    opt2_ = new ::std::string;
  }
  opt2_->assign(value);
}
inline void LoginReq::set_opt2(const char* value, size_t size) {
  set_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    opt2_ = new ::std::string;
  }
  opt2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_opt2() {
  set_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    opt2_ = new ::std::string;
  }
  return opt2_;
}
inline ::std::string* LoginReq::release_opt2() {
  clear_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opt2_;
    opt2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_opt2(::std::string* opt2) {
  if (opt2_ != &::google::protobuf::internal::kEmptyString) {
    delete opt2_;
  }
  if (opt2) {
    set_has_opt2();
    opt2_ = opt2;
  } else {
    clear_has_opt2();
    opt2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginRsp

// required int32 result = 1;
inline bool LoginRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRsp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LoginRsp::result() const {
  return result_;
}
inline void LoginRsp::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required string fail_result = 2;
inline bool LoginRsp::has_fail_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRsp::set_has_fail_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRsp::clear_has_fail_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRsp::clear_fail_result() {
  if (fail_result_ != &::google::protobuf::internal::kEmptyString) {
    fail_result_->clear();
  }
  clear_has_fail_result();
}
inline const ::std::string& LoginRsp::fail_result() const {
  return *fail_result_;
}
inline void LoginRsp::set_fail_result(const ::std::string& value) {
  set_has_fail_result();
  if (fail_result_ == &::google::protobuf::internal::kEmptyString) {
    fail_result_ = new ::std::string;
  }
  fail_result_->assign(value);
}
inline void LoginRsp::set_fail_result(const char* value) {
  set_has_fail_result();
  if (fail_result_ == &::google::protobuf::internal::kEmptyString) {
    fail_result_ = new ::std::string;
  }
  fail_result_->assign(value);
}
inline void LoginRsp::set_fail_result(const char* value, size_t size) {
  set_has_fail_result();
  if (fail_result_ == &::google::protobuf::internal::kEmptyString) {
    fail_result_ = new ::std::string;
  }
  fail_result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRsp::mutable_fail_result() {
  set_has_fail_result();
  if (fail_result_ == &::google::protobuf::internal::kEmptyString) {
    fail_result_ = new ::std::string;
  }
  return fail_result_;
}
inline ::std::string* LoginRsp::release_fail_result() {
  clear_has_fail_result();
  if (fail_result_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fail_result_;
    fail_result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRsp::set_allocated_fail_result(::std::string* fail_result) {
  if (fail_result_ != &::google::protobuf::internal::kEmptyString) {
    delete fail_result_;
  }
  if (fail_result) {
    set_has_fail_result();
    fail_result_ = fail_result;
  } else {
    clear_has_fail_result();
    fail_result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string opt2 = 3;
inline bool LoginRsp::has_opt2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRsp::set_has_opt2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRsp::clear_has_opt2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRsp::clear_opt2() {
  if (opt2_ != &::google::protobuf::internal::kEmptyString) {
    opt2_->clear();
  }
  clear_has_opt2();
}
inline const ::std::string& LoginRsp::opt2() const {
  return *opt2_;
}
inline void LoginRsp::set_opt2(const ::std::string& value) {
  set_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    opt2_ = new ::std::string;
  }
  opt2_->assign(value);
}
inline void LoginRsp::set_opt2(const char* value) {
  set_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    opt2_ = new ::std::string;
  }
  opt2_->assign(value);
}
inline void LoginRsp::set_opt2(const char* value, size_t size) {
  set_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    opt2_ = new ::std::string;
  }
  opt2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRsp::mutable_opt2() {
  set_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    opt2_ = new ::std::string;
  }
  return opt2_;
}
inline ::std::string* LoginRsp::release_opt2() {
  clear_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opt2_;
    opt2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRsp::set_allocated_opt2(::std::string* opt2) {
  if (opt2_ != &::google::protobuf::internal::kEmptyString) {
    delete opt2_;
  }
  if (opt2) {
    set_has_opt2();
    opt2_ = opt2;
  } else {
    clear_has_opt2();
    opt2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserInfo

// required int32 gold_count = 1;
inline bool UserInfo::has_gold_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_gold_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_gold_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_gold_count() {
  gold_count_ = 0;
  clear_has_gold_count();
}
inline ::google::protobuf::int32 UserInfo::gold_count() const {
  return gold_count_;
}
inline void UserInfo::set_gold_count(::google::protobuf::int32 value) {
  set_has_gold_count();
  gold_count_ = value;
}

// required int32 user_type = 2;
inline bool UserInfo::has_user_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_user_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_user_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_user_type() {
  user_type_ = 0;
  clear_has_user_type();
}
inline ::google::protobuf::int32 UserInfo::user_type() const {
  return user_type_;
}
inline void UserInfo::set_user_type(::google::protobuf::int32 value) {
  set_has_user_type();
  user_type_ = value;
}

// required int32 user_grade = 3;
inline bool UserInfo::has_user_grade() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_user_grade() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_user_grade() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_user_grade() {
  user_grade_ = 0;
  clear_has_user_grade();
}
inline ::google::protobuf::int32 UserInfo::user_grade() const {
  return user_grade_;
}
inline void UserInfo::set_user_grade(::google::protobuf::int32 value) {
  set_has_user_grade();
  user_grade_ = value;
}

// optional string opt1 = 4;
inline bool UserInfo::has_opt1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_opt1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_opt1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_opt1() {
  if (opt1_ != &::google::protobuf::internal::kEmptyString) {
    opt1_->clear();
  }
  clear_has_opt1();
}
inline const ::std::string& UserInfo::opt1() const {
  return *opt1_;
}
inline void UserInfo::set_opt1(const ::std::string& value) {
  set_has_opt1();
  if (opt1_ == &::google::protobuf::internal::kEmptyString) {
    opt1_ = new ::std::string;
  }
  opt1_->assign(value);
}
inline void UserInfo::set_opt1(const char* value) {
  set_has_opt1();
  if (opt1_ == &::google::protobuf::internal::kEmptyString) {
    opt1_ = new ::std::string;
  }
  opt1_->assign(value);
}
inline void UserInfo::set_opt1(const char* value, size_t size) {
  set_has_opt1();
  if (opt1_ == &::google::protobuf::internal::kEmptyString) {
    opt1_ = new ::std::string;
  }
  opt1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_opt1() {
  set_has_opt1();
  if (opt1_ == &::google::protobuf::internal::kEmptyString) {
    opt1_ = new ::std::string;
  }
  return opt1_;
}
inline ::std::string* UserInfo::release_opt1() {
  clear_has_opt1();
  if (opt1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opt1_;
    opt1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_opt1(::std::string* opt1) {
  if (opt1_ != &::google::protobuf::internal::kEmptyString) {
    delete opt1_;
  }
  if (opt1) {
    set_has_opt1();
    opt1_ = opt1;
  } else {
    clear_has_opt1();
    opt1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string opt2 = 5;
inline bool UserInfo::has_opt2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_opt2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_opt2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_opt2() {
  if (opt2_ != &::google::protobuf::internal::kEmptyString) {
    opt2_->clear();
  }
  clear_has_opt2();
}
inline const ::std::string& UserInfo::opt2() const {
  return *opt2_;
}
inline void UserInfo::set_opt2(const ::std::string& value) {
  set_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    opt2_ = new ::std::string;
  }
  opt2_->assign(value);
}
inline void UserInfo::set_opt2(const char* value) {
  set_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    opt2_ = new ::std::string;
  }
  opt2_->assign(value);
}
inline void UserInfo::set_opt2(const char* value, size_t size) {
  set_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    opt2_ = new ::std::string;
  }
  opt2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_opt2() {
  set_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    opt2_ = new ::std::string;
  }
  return opt2_;
}
inline ::std::string* UserInfo::release_opt2() {
  clear_has_opt2();
  if (opt2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opt2_;
    opt2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_opt2(::std::string* opt2) {
  if (opt2_ != &::google::protobuf::internal::kEmptyString) {
    delete opt2_;
  }
  if (opt2) {
    set_has_opt2();
    opt2_ = opt2;
  } else {
    clear_has_opt2();
    opt2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HallBoard

// required string board1 = 1;
inline bool HallBoard::has_board1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HallBoard::set_has_board1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HallBoard::clear_has_board1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HallBoard::clear_board1() {
  if (board1_ != &::google::protobuf::internal::kEmptyString) {
    board1_->clear();
  }
  clear_has_board1();
}
inline const ::std::string& HallBoard::board1() const {
  return *board1_;
}
inline void HallBoard::set_board1(const ::std::string& value) {
  set_has_board1();
  if (board1_ == &::google::protobuf::internal::kEmptyString) {
    board1_ = new ::std::string;
  }
  board1_->assign(value);
}
inline void HallBoard::set_board1(const char* value) {
  set_has_board1();
  if (board1_ == &::google::protobuf::internal::kEmptyString) {
    board1_ = new ::std::string;
  }
  board1_->assign(value);
}
inline void HallBoard::set_board1(const char* value, size_t size) {
  set_has_board1();
  if (board1_ == &::google::protobuf::internal::kEmptyString) {
    board1_ = new ::std::string;
  }
  board1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HallBoard::mutable_board1() {
  set_has_board1();
  if (board1_ == &::google::protobuf::internal::kEmptyString) {
    board1_ = new ::std::string;
  }
  return board1_;
}
inline ::std::string* HallBoard::release_board1() {
  clear_has_board1();
  if (board1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = board1_;
    board1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HallBoard::set_allocated_board1(::std::string* board1) {
  if (board1_ != &::google::protobuf::internal::kEmptyString) {
    delete board1_;
  }
  if (board1) {
    set_has_board1();
    board1_ = board1;
  } else {
    clear_has_board1();
    board1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string board2 = 2;
inline bool HallBoard::has_board2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HallBoard::set_has_board2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HallBoard::clear_has_board2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HallBoard::clear_board2() {
  if (board2_ != &::google::protobuf::internal::kEmptyString) {
    board2_->clear();
  }
  clear_has_board2();
}
inline const ::std::string& HallBoard::board2() const {
  return *board2_;
}
inline void HallBoard::set_board2(const ::std::string& value) {
  set_has_board2();
  if (board2_ == &::google::protobuf::internal::kEmptyString) {
    board2_ = new ::std::string;
  }
  board2_->assign(value);
}
inline void HallBoard::set_board2(const char* value) {
  set_has_board2();
  if (board2_ == &::google::protobuf::internal::kEmptyString) {
    board2_ = new ::std::string;
  }
  board2_->assign(value);
}
inline void HallBoard::set_board2(const char* value, size_t size) {
  set_has_board2();
  if (board2_ == &::google::protobuf::internal::kEmptyString) {
    board2_ = new ::std::string;
  }
  board2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HallBoard::mutable_board2() {
  set_has_board2();
  if (board2_ == &::google::protobuf::internal::kEmptyString) {
    board2_ = new ::std::string;
  }
  return board2_;
}
inline ::std::string* HallBoard::release_board2() {
  clear_has_board2();
  if (board2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = board2_;
    board2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HallBoard::set_allocated_board2(::std::string* board2) {
  if (board2_ != &::google::protobuf::internal::kEmptyString) {
    delete board2_;
  }
  if (board2) {
    set_has_board2();
    board2_ = board2;
  } else {
    clear_has_board2();
    board2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string board3 = 3;
inline bool HallBoard::has_board3() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HallBoard::set_has_board3() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HallBoard::clear_has_board3() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HallBoard::clear_board3() {
  if (board3_ != &::google::protobuf::internal::kEmptyString) {
    board3_->clear();
  }
  clear_has_board3();
}
inline const ::std::string& HallBoard::board3() const {
  return *board3_;
}
inline void HallBoard::set_board3(const ::std::string& value) {
  set_has_board3();
  if (board3_ == &::google::protobuf::internal::kEmptyString) {
    board3_ = new ::std::string;
  }
  board3_->assign(value);
}
inline void HallBoard::set_board3(const char* value) {
  set_has_board3();
  if (board3_ == &::google::protobuf::internal::kEmptyString) {
    board3_ = new ::std::string;
  }
  board3_->assign(value);
}
inline void HallBoard::set_board3(const char* value, size_t size) {
  set_has_board3();
  if (board3_ == &::google::protobuf::internal::kEmptyString) {
    board3_ = new ::std::string;
  }
  board3_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HallBoard::mutable_board3() {
  set_has_board3();
  if (board3_ == &::google::protobuf::internal::kEmptyString) {
    board3_ = new ::std::string;
  }
  return board3_;
}
inline ::std::string* HallBoard::release_board3() {
  clear_has_board3();
  if (board3_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = board3_;
    board3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HallBoard::set_allocated_board3(::std::string* board3) {
  if (board3_ != &::google::protobuf::internal::kEmptyString) {
    delete board3_;
  }
  if (board3) {
    set_has_board3();
    board3_ = board3;
  } else {
    clear_has_board3();
    board3_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string board4 = 4;
inline bool HallBoard::has_board4() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HallBoard::set_has_board4() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HallBoard::clear_has_board4() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HallBoard::clear_board4() {
  if (board4_ != &::google::protobuf::internal::kEmptyString) {
    board4_->clear();
  }
  clear_has_board4();
}
inline const ::std::string& HallBoard::board4() const {
  return *board4_;
}
inline void HallBoard::set_board4(const ::std::string& value) {
  set_has_board4();
  if (board4_ == &::google::protobuf::internal::kEmptyString) {
    board4_ = new ::std::string;
  }
  board4_->assign(value);
}
inline void HallBoard::set_board4(const char* value) {
  set_has_board4();
  if (board4_ == &::google::protobuf::internal::kEmptyString) {
    board4_ = new ::std::string;
  }
  board4_->assign(value);
}
inline void HallBoard::set_board4(const char* value, size_t size) {
  set_has_board4();
  if (board4_ == &::google::protobuf::internal::kEmptyString) {
    board4_ = new ::std::string;
  }
  board4_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HallBoard::mutable_board4() {
  set_has_board4();
  if (board4_ == &::google::protobuf::internal::kEmptyString) {
    board4_ = new ::std::string;
  }
  return board4_;
}
inline ::std::string* HallBoard::release_board4() {
  clear_has_board4();
  if (board4_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = board4_;
    board4_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HallBoard::set_allocated_board4(::std::string* board4) {
  if (board4_ != &::google::protobuf::internal::kEmptyString) {
    delete board4_;
  }
  if (board4) {
    set_has_board4();
    board4_ = board4;
  } else {
    clear_has_board4();
    board4_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string board5 = 5;
inline bool HallBoard::has_board5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HallBoard::set_has_board5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HallBoard::clear_has_board5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HallBoard::clear_board5() {
  if (board5_ != &::google::protobuf::internal::kEmptyString) {
    board5_->clear();
  }
  clear_has_board5();
}
inline const ::std::string& HallBoard::board5() const {
  return *board5_;
}
inline void HallBoard::set_board5(const ::std::string& value) {
  set_has_board5();
  if (board5_ == &::google::protobuf::internal::kEmptyString) {
    board5_ = new ::std::string;
  }
  board5_->assign(value);
}
inline void HallBoard::set_board5(const char* value) {
  set_has_board5();
  if (board5_ == &::google::protobuf::internal::kEmptyString) {
    board5_ = new ::std::string;
  }
  board5_->assign(value);
}
inline void HallBoard::set_board5(const char* value, size_t size) {
  set_has_board5();
  if (board5_ == &::google::protobuf::internal::kEmptyString) {
    board5_ = new ::std::string;
  }
  board5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HallBoard::mutable_board5() {
  set_has_board5();
  if (board5_ == &::google::protobuf::internal::kEmptyString) {
    board5_ = new ::std::string;
  }
  return board5_;
}
inline ::std::string* HallBoard::release_board5() {
  clear_has_board5();
  if (board5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = board5_;
    board5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HallBoard::set_allocated_board5(::std::string* board5) {
  if (board5_ != &::google::protobuf::internal::kEmptyString) {
    delete board5_;
  }
  if (board5) {
    set_has_board5();
    board5_ = board5;
  } else {
    clear_has_board5();
    board5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string board6 = 6;
inline bool HallBoard::has_board6() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HallBoard::set_has_board6() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HallBoard::clear_has_board6() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HallBoard::clear_board6() {
  if (board6_ != &::google::protobuf::internal::kEmptyString) {
    board6_->clear();
  }
  clear_has_board6();
}
inline const ::std::string& HallBoard::board6() const {
  return *board6_;
}
inline void HallBoard::set_board6(const ::std::string& value) {
  set_has_board6();
  if (board6_ == &::google::protobuf::internal::kEmptyString) {
    board6_ = new ::std::string;
  }
  board6_->assign(value);
}
inline void HallBoard::set_board6(const char* value) {
  set_has_board6();
  if (board6_ == &::google::protobuf::internal::kEmptyString) {
    board6_ = new ::std::string;
  }
  board6_->assign(value);
}
inline void HallBoard::set_board6(const char* value, size_t size) {
  set_has_board6();
  if (board6_ == &::google::protobuf::internal::kEmptyString) {
    board6_ = new ::std::string;
  }
  board6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HallBoard::mutable_board6() {
  set_has_board6();
  if (board6_ == &::google::protobuf::internal::kEmptyString) {
    board6_ = new ::std::string;
  }
  return board6_;
}
inline ::std::string* HallBoard::release_board6() {
  clear_has_board6();
  if (board6_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = board6_;
    board6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HallBoard::set_allocated_board6(::std::string* board6) {
  if (board6_ != &::google::protobuf::internal::kEmptyString) {
    delete board6_;
  }
  if (board6) {
    set_has_board6();
    board6_ = board6;
  } else {
    clear_has_board6();
    board6_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_AccessMsg_2eproto__INCLUDED
